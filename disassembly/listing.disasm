Disassembly Listing for Project_ATCS
Generated From:
E:/WATAKUMI/PIC/Project_ATCS/dist/default/debug/Project_ATCS.debug.elf
2023/12/15 1:23:35

---  E:/WATAKUMI/PIC/Project_ATCS/Project_ATCS_Decorder_Module.c  ---------------------------------------
1:             /*
2:              * File:   Project_ATCS_Decorder_SinkLayer.c
3:              * Author: WATANABE
4:              * ver 0.1
5:              * Created on November 22, 2023, 11:35 PM
6:              */
7:             
8:             
9:             #include <xc.h>
10:            #include "Project_ATCS_SETUP.h"
11:            
12:            void EEPROM_SELECT(void) {
13:                INTCONbits.GIE = 0;                                                         //割り込み禁止
00F6  138B     BCF INTCON, 0x7
02B5  138B     BCF INTCON, 0x7
14:                UnCHR COUNT = 0x00 ;
00F7  0020     MOVLB 0x0
00F8  01A4     CLRF COUNT
02B6  01F4     CLRF COUNT
15:                
16:                switch (EE_STORE.EE_STATE) {                                                //EE_STATEより
00F9  2A98     GOTO 0x298
02B7  2C42     GOTO 0x442
17:                    case EE_READ_S:                                                         //読み込みシングルモード
18:                        do{
19:                            if(EE_STORE.EE_REPORT[COUNT]){
00FA  0824     MOVF COUNT, W
00FB  3E58     ADDLW 0x58
00FC  0086     MOVWF FSR1
00FD  0187     CLRF FSR1H
00FE  0801     MOVF INDF1, W
00FF  1903     BTFSC STATUS, 0x2
0100  2902     GOTO 0x102
0101  2903     GOTO 0x103
0102  2924     GOTO 0x124
02B8  0874     MOVF COUNT, W
02B9  3E58     ADDLW 0x58
02BA  0086     MOVWF FSR1
02BB  0187     CLRF FSR1H
02BC  0801     MOVF INDF1, W
02BD  1903     BTFSC STATUS, 0x2
02BE  2AC0     GOTO 0x2C0
02BF  2AC1     GOTO 0x2C1
02C0  2ADF     GOTO 0x2DF
20:                                EEADR = EE_STORE.EE_ADRS;
0103  084F     MOVF 0x4F, W
0104  0023     MOVLB 0x3
0105  0092     MOVWF EEADRH
0106  0020     MOVLB 0x0
0107  084E     MOVF 0x4E, W
0108  0023     MOVLB 0x3
0109  0091     MOVWF EEADR
02C1  084F     MOVF 0x1CF, W
02C2  0023     MOVLB 0x3
02C3  0092     MOVWF EEADRH
02C4  0020     MOVLB 0x0
02C5  084E     MOVF 0x4E, W
02C6  0023     MOVLB 0x3
02C7  0091     MOVWF EEADR
21:                                EECON1 = EE_STORE.EE_CONFIG;
010A  0020     MOVLB 0x0
010B  084D     MOVF 0x4D, W
010C  0023     MOVLB 0x3
010D  0095     MOVWF EECON1
02C8  0020     MOVLB 0x0
02C9  084D     MOVF 0x4D, W
02CA  0023     MOVLB 0x3
02CB  0095     MOVWF EECON1
22:                                while (EECON1bits.RD);
010E  1815     BTFSC EECON1, 0x0
010F  2911     GOTO 0x111
0110  2912     GOTO 0x112
0111  290E     GOTO 0x10E
02CC  1815     BTFSC EECON1, 0x0
02CD  2ACF     GOTO 0x2CF
02CE  2AD0     GOTO 0x2D0
02CF  2ACC     GOTO 0x2CC
23:                                EE_STORE.EE_DATA[COUNT] = EEDAT;
0112  0020     MOVLB 0x0
0113  3524     LSLF COUNT, W
0114  3E50     ADDLW 0x50
0115  0086     MOVWF FSR1
0116  0187     CLRF FSR1H
0117  0023     MOVLB 0x3
0118  0813     MOVF EEDAT, W
0119  3FC0     MOVWI 0[FSR1]
011A  0814     MOVF EEDATH, W
011B  3FC1     MOVWI 1[FSR1]
02D0  3574     LSLF 0x1F4, W
02D1  3E50     ADDLW 0x50
02D2  0086     MOVWF FSR1L
02D3  0187     CLRF FSR1H
02D4  0813     MOVF EEDAT, W
02D5  3FC0     MOVWI 0[FSR1]
02D6  0814     MOVF EEDATH, W
02D7  3FC1     MOVWI 1[FSR1]
24:                                INTCONbits.GIE = 1;
011C  178B     BSF INTCON, 0x7
02D8  178B     BSF INTCON, 0x7
25:                                EE_STORE.EE_REPORT[COUNT] = 0x00;
011D  0020     MOVLB 0x0
011E  0824     MOVF COUNT, W
011F  3E58     ADDLW 0x58
0120  0086     MOVWF FSR1
0121  0187     CLRF FSR1H
0122  0181     CLRF INDF1
0123  2AB4     GOTO 0x2B4
02D9  0874     MOVF COUNT, W
02DA  3E58     ADDLW 0x58
02DB  0086     MOVWF FSR1
02DC  0187     CLRF FSR1H
02DD  0181     CLRF INDF1
02DE  2C5F     GOTO 0x45F
26:                                return;
27:                            }
28:                            COUNT++;
0124  3001     MOVLW 0x1
0125  00A0     MOVWF __pcstackBANK0
0126  0820     MOVF __pcstackBANK0, W
0127  07A4     ADDWF COUNT, F
02DF  3001     MOVLW 0x1
02E0  00F0     MOVWF __pcstackCOMMON
02E1  0870     MOVF __pcstackCOMMON, W
02E2  07F4     ADDWF COUNT, F
29:                            EEADR = EE_STORE.EE_ADRS++;
0128  084F     MOVF 0x4F, W
0129  0023     MOVLB 0x3
012A  0092     MOVWF EEADRH
012B  0020     MOVLB 0x0
012C  084E     MOVF 0x4E, W
012D  0023     MOVLB 0x3
012E  0091     MOVWF EEADR
012F  3001     MOVLW 0x1
0130  0020     MOVLB 0x0
0131  07CE     ADDWF 0x4E, F
0132  3000     MOVLW 0x0
0133  3DCF     ADDWFC 0x4F, F
02E3  084F     MOVF 0x4F, W
02E4  0023     MOVLB 0x3
02E5  0092     MOVWF EEADRH
02E6  0020     MOVLB 0x0
02E7  084E     MOVF 0x4E, W
02E8  0023     MOVLB 0x3
02E9  0091     MOVWF EEADR
02EA  3001     MOVLW 0x1
02EB  0020     MOVLB 0x0
02EC  07CE     ADDWF 0x4E, F
02ED  3000     MOVLW 0x0
02EE  3DCF     ADDWFC 0x4F, F
30:                        }while(COUNT < 4);
0134  3004     MOVLW 0x4
0135  0224     SUBWF COUNT, W
0136  1C03     BTFSS STATUS, 0x0
0137  2939     GOTO 0x139
0138  293A     GOTO 0x13A
0139  28FA     GOTO 0xFA
013A  2AB4     GOTO 0x2B4
02EF  3004     MOVLW 0x4
02F0  0274     SUBWF COUNT, W
02F1  1C03     BTFSS STATUS, 0x0
02F2  2AF4     GOTO 0x2F4
02F3  2AF5     GOTO 0x2F5
02F4  2AB8     GOTO 0x2B8
02F5  2C5F     GOTO 0x45F
31:                        return;
32:            
33:                    case EE_READ_M:                                                         //読み込みマルチ 
34:                        do {
35:                            if(EE_STORE.EE_REPORT[COUNT]){
013B  0824     MOVF COUNT, W
013C  3E58     ADDLW 0x58
013D  0086     MOVWF FSR1
013E  0187     CLRF FSR1H
013F  0801     MOVF INDF1, W
0140  1903     BTFSC STATUS, 0x2
0141  2943     GOTO 0x143
0142  2944     GOTO 0x144
0143  2964     GOTO 0x164
02F6  0874     MOVF COUNT, W
02F7  3E58     ADDLW 0x58
02F8  0086     MOVWF FSR1
02F9  0187     CLRF FSR1H
02FA  0801     MOVF INDF1, W
02FB  1903     BTFSC STATUS, 0x2
02FC  2AFE     GOTO 0x2FE
02FD  2AFF     GOTO 0x2FF
02FE  2B1C     GOTO 0x31C
36:                                EEADR = EE_STORE.EE_ADRS;
0144  084F     MOVF 0x4F, W
0145  0023     MOVLB 0x3
0146  0092     MOVWF EEADRH
0147  0020     MOVLB 0x0
0148  084E     MOVF 0x4E, W
0149  0023     MOVLB 0x3
014A  0091     MOVWF EEADR
02FF  084F     MOVF 0x1CF, W
0300  0023     MOVLB 0x3
0301  0092     MOVWF EEADRH
0302  0020     MOVLB 0x0
0303  084E     MOVF 0x4E, W
0304  0023     MOVLB 0x3
0305  0091     MOVWF EEADR
37:                                EECON1 = EE_STORE.EE_CONFIG;
014B  0020     MOVLB 0x0
014C  084D     MOVF 0x4D, W
014D  0023     MOVLB 0x3
014E  0095     MOVWF EECON1
0306  0020     MOVLB 0x0
0307  084D     MOVF 0x4D, W
0308  0023     MOVLB 0x3
0309  0095     MOVWF EECON1
38:                                EECON1bits.RD = 1;
014F  1415     BSF EECON1, 0x0
030A  1415     BSF EECON1, 0x0
39:                                while (EECON1bits.RD);
0150  1815     BTFSC EECON1, 0x0
0151  2953     GOTO 0x153
0152  2954     GOTO 0x154
0153  2950     GOTO 0x150
030B  1815     BTFSC EECON1, 0x0
030C  2B0E     GOTO 0x30E
030D  2B0F     GOTO 0x30F
030E  2B0B     GOTO 0x30B
40:                                EE_STORE.EE_DATA[COUNT] = EEDAT;
0154  0020     MOVLB 0x0
0155  3524     LSLF COUNT, W
0156  3E50     ADDLW 0x50
0157  0086     MOVWF FSR1
0158  0187     CLRF FSR1H
0159  0023     MOVLB 0x3
015A  0813     MOVF EEDAT, W
015B  3FC0     MOVWI 0[FSR1]
015C  0814     MOVF EEDATH, W
015D  3FC1     MOVWI 1[FSR1]
030F  3574     LSLF 0x1F4, W
0310  3E50     ADDLW 0x50
0311  0086     MOVWF FSR1L
0312  0187     CLRF FSR1H
0313  0813     MOVF EEDAT, W
0314  3FC0     MOVWI 0[FSR1]
0315  0814     MOVF EEDATH, W
0316  3FC1     MOVWI 1[FSR1]
41:                                EE_STORE.EE_REPORT[COUNT] = 0x00;
015E  0020     MOVLB 0x0
015F  0824     MOVF COUNT, W
0160  3E58     ADDLW 0x58
0161  0086     MOVWF FSR1
0162  0187     CLRF FSR1H
0163  0181     CLRF INDF1
0317  0874     MOVF COUNT, W
0318  3E58     ADDLW 0x58
0319  0086     MOVWF FSR1
031A  0187     CLRF FSR1H
031B  0181     CLRF INDF1
42:                            }
43:                            EE_STORE.EE_ADRS++;
0164  3001     MOVLW 0x1
0165  07CE     ADDWF 0x4E, F
0166  3000     MOVLW 0x0
0167  3DCF     ADDWFC 0x4F, F
031C  3001     MOVLW 0x1
031D  0020     MOVLB 0x0
031E  07CE     ADDWF 0x4E, F
031F  3000     MOVLW 0x0
0320  3DCF     ADDWFC 0x4F, F
44:                        } while (COUNT < 4);
0168  3004     MOVLW 0x4
0169  0224     SUBWF COUNT, W
016A  1C03     BTFSS STATUS, 0x0
016B  296D     GOTO 0x16D
016C  296E     GOTO 0x16E
016D  293B     GOTO 0x13B
0321  3004     MOVLW 0x4
0322  0274     SUBWF COUNT, W
0323  1C03     BTFSS STATUS, 0x0
0324  2B26     GOTO 0x326
0325  2B27     GOTO 0x327
0326  2AF6     GOTO 0x2F6
45:                        INTCONbits.GIE = 1;
016E  178B     BSF INTCON, 0x7
0327  178B     BSF INTCON, 0x7
46:                        return;
016F  2AB4     GOTO 0x2B4
0328  2C5F     GOTO 0x45F
47:            
48:                    case EE_WRITE_UID:                                                      //ユーザーID書き込み
49:                        INTCONbits.GIE = 0;                                                 //シーケンス開始
0170  138B     BCF INTCON, 0x7
0329  138B     BCF INTCON, 0x7
50:                        UnINT EE_SAVE = EE_STORE.EE_ADRS;
0171  084F     MOVF 0x4F, W
0172  00A3     MOVWF 0x23
0173  084E     MOVF 0x4E, W
0174  00A2     MOVWF P_RANGE
032A  084F     MOVF 0x4F, W
032B  00F3     MOVWF 0x73
032C  084E     MOVF 0x4E, W
032D  00F2     MOVWF EE_SAVE
51:                        do {
52:                            if(EE_STORE.EE_REPORT[COUNT]){
0175  0824     MOVF COUNT, W
0176  3E58     ADDLW 0x58
0177  0086     MOVWF FSR1
0178  0187     CLRF FSR1H
0179  0801     MOVF INDF1, W
017A  1903     BTFSC STATUS, 0x2
017B  297D     GOTO 0x17D
017C  297E     GOTO 0x17E
017D  2996     GOTO 0x196
032E  0874     MOVF COUNT, W
032F  3E58     ADDLW 0x58
0330  0086     MOVWF FSR1
0331  0187     CLRF FSR1H
0332  0801     MOVF INDF1, W
0333  1903     BTFSC STATUS, 0x2
0334  2B36     GOTO 0x336
0335  2B37     GOTO 0x337
0336  2B4D     GOTO 0x34D
53:                                EEADR = EE_STORE.EE_ADRS;
017E  084F     MOVF 0x4F, W
017F  0023     MOVLB 0x3
0180  0092     MOVWF EEADRH
0181  0020     MOVLB 0x0
0182  084E     MOVF 0x4E, W
0183  0023     MOVLB 0x3
0184  0091     MOVWF EEADR
0337  084F     MOVF 0x1CF, W
0338  0023     MOVLB 0x3
0339  0092     MOVWF EEADRH
033A  0020     MOVLB 0x0
033B  084E     MOVF 0x4E, W
033C  0023     MOVLB 0x3
033D  0091     MOVWF EEADR
54:                                EEDAT = EE_STORE.EE_DATA[COUNT];
0185  0020     MOVLB 0x0
0186  3524     LSLF COUNT, W
0187  3E50     ADDLW 0x50
0188  0086     MOVWF FSR1
0189  0187     CLRF FSR1H
018A  3F40     MOVIW 0[FSR1]
018B  0023     MOVLB 0x3
018C  0093     MOVWF EEDAT
018D  3F41     MOVIW 1[FSR1]
018E  0094     MOVWF EEDATH
033E  3574     LSLF 0x1F4, W
033F  3E50     ADDLW 0x50
0340  0086     MOVWF FSR1L
0341  0187     CLRF FSR1H
0342  3F40     MOVIW 0[FSR1]
0343  0093     MOVWF EEDAT
0344  3F41     MOVIW 1[FSR1]
0345  0094     MOVWF EEDATH
55:                                EECON1 = 0x64;
018F  3064     MOVLW 0x64
0190  0095     MOVWF EECON1
0346  3064     MOVLW 0x64
0347  0095     MOVWF EECON1
56:                                EECON2 = 0x55;
0191  3055     MOVLW 0x55
0192  0096     MOVWF EECON2
0348  3055     MOVLW 0x55
0349  0096     MOVWF EECON2
57:                                EECON2 = 0xAA;
0193  30AA     MOVLW 0xAA
0194  0096     MOVWF EECON2
034A  30AA     MOVLW 0xAA
034B  0096     MOVWF EECON2
58:                                EECON1bits.WR = 1;
0195  1495     BSF EECON1, 0x1
034C  1495     BSF EECON1, 0x1
59:                            }
60:                            COUNT++;
0196  3001     MOVLW 0x1
0197  0020     MOVLB 0x0
0198  00A0     MOVWF __pcstackBANK0
0199  0820     MOVF __pcstackBANK0, W
019A  07A4     ADDWF COUNT, F
034D  3001     MOVLW 0x1
034E  00F0     MOVWF __pcstackCOMMON
034F  0870     MOVF __pcstackCOMMON, W
0350  07F4     ADDWF COUNT, F
61:                            EE_STORE.EE_ADRS++;
019B  3001     MOVLW 0x1
019C  07CE     ADDWF 0x4E, F
019D  3000     MOVLW 0x0
019E  3DCF     ADDWFC 0x4F, F
0351  3001     MOVLW 0x1
0352  0020     MOVLB 0x0
0353  07CE     ADDWF 0x4E, F
0354  3000     MOVLW 0x0
0355  3DCF     ADDWFC 0x4F, F
62:                        } while (COUNT < 4);
019F  3004     MOVLW 0x4
01A0  0224     SUBWF COUNT, W
01A1  1C03     BTFSS STATUS, 0x0
01A2  29A4     GOTO 0x1A4
01A3  29A5     GOTO 0x1A5
01A4  2975     GOTO 0x175
0356  3004     MOVLW 0x4
0357  0274     SUBWF COUNT, W
0358  1C03     BTFSS STATUS, 0x0
0359  2B5B     GOTO 0x35B
035A  2B5C     GOTO 0x35C
035B  2B2E     GOTO 0x32E
63:                        EE_STORE.EE_ADRS = EE_SAVE;
01A5  0823     MOVF 0x23, W
01A6  00CF     MOVWF 0x4F
01A7  0822     MOVF P_RANGE, W
01A8  00CE     MOVWF 0x4E
035C  0873     MOVF 0x73, W
035D  00CF     MOVWF 0x4F
035E  0872     MOVF EE_SAVE, W
035F  00CE     MOVWF 0x4E
64:                        
65:                        EECON1 = 0x44;
01A9  3044     MOVLW 0x44
01AA  0023     MOVLB 0x3
01AB  0095     MOVWF EECON1
0360  3044     MOVLW 0x44
0361  0023     MOVLB 0x3
0362  0095     MOVWF EECON1
66:                        EECON2 = 0x55;
01AC  3055     MOVLW 0x55
01AD  0096     MOVWF EECON2
0363  3055     MOVLW 0x55
0364  0096     MOVWF EECON2
67:                        EECON2 = 0xAA;
01AE  30AA     MOVLW 0xAA
01AF  0096     MOVWF EECON2
0365  30AA     MOVLW 0xAA
0366  0096     MOVWF EECON2
68:            
69:                        EECON1bits.WR = 1;
01B0  1495     BSF EECON1, 0x1
0367  1495     BSF EECON1, 0x1
70:                        NOP();
01B1  0000     NOP
0368  0000     NOP
71:                        NOP();
01B2  0000     NOP
0369  0000     NOP
72:                        INTCONbits.GIE = 1;
01B3  178B     BSF INTCON, 0x7
01B4  2AB4     GOTO 0x2B4
036A  178B     BSF INTCON, 0x7
036B  2C5F     GOTO 0x45F
73:                        return;                                                             //メインに戻す
74:            
75:                    case EE_VERIFY_UID:                                                     //ユーザー書込成否チェック
76:                        INTCONbits.GIE = 0;
01B5  138B     BCF INTCON, 0x7
036C  138B     BCF INTCON, 0x7
77:                        do {
78:                            if(EE_STORE.EE_REPORT[COUNT]){
01B6  0824     MOVF 0x1A4, W
01B7  3E58     ADDLW 0x58
01B8  0086     MOVWF FSR1L
01B9  0187     CLRF FSR1H
01BA  0801     MOVF INDF1, W
01BB  1903     BTFSC STATUS, 0x2
01BC  29BE     GOTO 0x1BE
01BD  29BF     GOTO 0x1BF
01BE  29EF     GOTO 0x1EF
036D  0874     MOVF 0x1F4, W
036E  3E58     ADDLW 0x58
036F  0086     MOVWF FSR1L
0370  0187     CLRF FSR1H
0371  0801     MOVF INDF1, W
0372  1903     BTFSC STATUS, 0x2
0373  2B75     GOTO 0x375
0374  2B76     GOTO 0x376
0375  2BA1     GOTO 0x3A1
79:                                EEADR = EE_STORE.EE_ADRS;
01BF  084F     MOVF 0x1CF, W
01C0  0023     MOVLB 0x3
01C1  0092     MOVWF EEADRH
01C2  0020     MOVLB 0x0
01C3  084E     MOVF 0x4E, W
01C4  0023     MOVLB 0x3
01C5  0091     MOVWF EEADR
0376  084F     MOVF 0x1CF, W
0377  0023     MOVLB 0x3
0378  0092     MOVWF EEADRH
0379  0020     MOVLB 0x0
037A  084E     MOVF 0x4E, W
037B  0023     MOVLB 0x3
037C  0091     MOVWF EEADR
80:                                EECON1 = 0x41;
01C6  3041     MOVLW 0x41
01C7  0095     MOVWF EECON1
037D  3041     MOVLW 0x41
037E  0095     MOVWF EECON1
81:                                while (EECON1bits.RD);
01C8  1815     BTFSC EECON1, 0x0
01C9  29CB     GOTO 0x1CB
01CA  29CC     GOTO 0x1CC
01CB  29C8     GOTO 0x1C8
037F  1815     BTFSC EECON1, 0x0
0380  2B82     GOTO 0x382
0381  2B83     GOTO 0x383
0382  2B7F     GOTO 0x37F
82:                                if (EEDAT != EE_STORE.EE_DATA[COUNT]) {
01CC  0020     MOVLB 0x0
01CD  3524     LSLF COUNT, W
01CE  3E50     ADDLW 0x50
01CF  0086     MOVWF FSR1
01D0  0187     CLRF FSR1H
01D1  3F40     MOVIW 0[FSR1]
01D2  00A0     MOVWF __pcstackBANK0
01D3  3F41     MOVIW 1[FSR1]
01D4  00A1     MOVWF 0x21
01D5  0023     MOVLB 0x3
01D6  0814     MOVF EEDATH, W
01D7  0020     MOVLB 0x0
01D8  0621     XORWF 0x21, W
01D9  1D03     BTFSS STATUS, 0x2
01DA  29DF     GOTO 0x1DF
01DB  0023     MOVLB 0x3
01DC  0813     MOVF EEDAT, W
01DD  0020     MOVLB 0x0
01DE  0620     XORWF __pcstackBANK0, W
01DF  1903     BTFSC STATUS, 0x2
01E0  29E2     GOTO 0x1E2
01E1  29E3     GOTO 0x1E3
01E2  29EA     GOTO 0x1EA
0383  3574     LSLF COUNT, W
0384  3E50     ADDLW 0x50
0385  0086     MOVWF FSR1
0386  0187     CLRF FSR1H
0387  3F40     MOVIW 0[FSR1]
0388  00F0     MOVWF __pcstackCOMMON
0389  3F41     MOVIW 1[FSR1]
038A  00F1     MOVWF 0x71
038B  0814     MOVF 0x14, W
038C  0671     XORWF 0x71, W
038D  1D03     BTFSS STATUS, 0x2
038E  2B91     GOTO 0x391
038F  0813     MOVF 0x13, W
0390  0670     XORWF __pcstackCOMMON, W
0391  1903     BTFSC STATUS, 0x2
0392  2B94     GOTO 0x394
0393  2B95     GOTO 0x395
0394  2B9C     GOTO 0x39C
83:                                    EE_STORE.EE_REPORT[COUNT] = 0xFF;
01E3  0824     MOVF COUNT, W
01E4  3E58     ADDLW 0x58
01E5  0086     MOVWF FSR1
01E6  0187     CLRF FSR1H
01E7  30FF     MOVLW 0xFF
01E8  0081     MOVWF INDF1
0395  0874     MOVF COUNT, W
0396  3E58     ADDLW 0x58
0397  0086     MOVWF FSR1
0398  0187     CLRF FSR1H
0399  30FF     MOVLW 0xFF
039A  0081     MOVWF INDF1
84:                                } else {
01E9  29EF     GOTO 0x1EF
039B  2BA1     GOTO 0x3A1
85:                                    EE_STORE.EE_REPORT[COUNT] = 0x00;
01EA  0824     MOVF COUNT, W
01EB  3E58     ADDLW 0x58
01EC  0086     MOVWF FSR1
01ED  0187     CLRF FSR1H
01EE  0181     CLRF INDF1
039C  0874     MOVF COUNT, W
039D  3E58     ADDLW 0x58
039E  0086     MOVWF FSR1
039F  0187     CLRF FSR1H
03A0  0181     CLRF INDF1
86:                                }
87:                            }
88:                            COUNT++;
01EF  3001     MOVLW 0x1
01F0  00A0     MOVWF __pcstackBANK0
01F1  0820     MOVF __pcstackBANK0, W
01F2  07A4     ADDWF COUNT, F
03A1  3001     MOVLW 0x1
03A2  00F0     MOVWF __pcstackCOMMON
03A3  0870     MOVF __pcstackCOMMON, W
03A4  07F4     ADDWF COUNT, F
89:                            EE_STORE.EE_ADRS++;
01F3  3001     MOVLW 0x1
01F4  07CE     ADDWF 0x4E, F
01F5  3000     MOVLW 0x0
01F6  3DCF     ADDWFC 0x4F, F
03A5  3001     MOVLW 0x1
03A6  0020     MOVLB 0x0
03A7  07CE     ADDWF 0x4E, F
03A8  3000     MOVLW 0x0
03A9  3DCF     ADDWFC 0x4F, F
90:                        } while (COUNT < 4);
01F7  3004     MOVLW 0x4
01F8  0224     SUBWF COUNT, W
01F9  1C03     BTFSS STATUS, 0x0
01FA  29FC     GOTO 0x1FC
01FB  29FD     GOTO 0x1FD
01FC  29B6     GOTO 0x1B6
03AA  3004     MOVLW 0x4
03AB  0274     SUBWF COUNT, W
03AC  1C03     BTFSS STATUS, 0x0
03AD  2BAF     GOTO 0x3AF
03AE  2BB0     GOTO 0x3B0
03AF  2B6D     GOTO 0x36D
91:                        INTCONbits.GIE = 1;
01FD  178B     BSF INTCON, 0x7
03B0  178B     BSF INTCON, 0x7
92:                        return;
01FE  2AB4     GOTO 0x2B4
03B1  2C5F     GOTO 0x45F
93:            
94:                    case EE_WRITE_ROM:                                                      //データEEPROM書き込み
95:                        do{
96:                            if(EE_STORE.EE_REPORT[COUNT]){
01FF  0824     MOVF COUNT, W
0200  3E58     ADDLW 0x58
0201  0086     MOVWF FSR1
0202  0187     CLRF FSR1H
0203  0801     MOVF INDF1, W
0204  1903     BTFSC STATUS, 0x2
0205  2A07     GOTO 0x207
0206  2A08     GOTO 0x208
0207  2A24     GOTO 0x224
03B2  0874     MOVF COUNT, W
03B3  3E58     ADDLW 0x58
03B4  0086     MOVWF FSR1
03B5  0187     CLRF FSR1H
03B6  0801     MOVF INDF1, W
03B7  1903     BTFSC STATUS, 0x2
03B8  2BBA     GOTO 0x3BA
03B9  2BBB     GOTO 0x3BB
03BA  2BD5     GOTO 0x3D5
97:                                EEADR = EE_STORE.EE_ADRS;
0208  084F     MOVF 0x4F, W
0209  0023     MOVLB 0x3
020A  0092     MOVWF EEADRH
020B  0020     MOVLB 0x0
020C  084E     MOVF 0x4E, W
020D  0023     MOVLB 0x3
020E  0091     MOVWF EEADR
03BB  084F     MOVF 0x1CF, W
03BC  0023     MOVLB 0x3
03BD  0092     MOVWF EEADRH
03BE  0020     MOVLB 0x0
03BF  084E     MOVF 0x4E, W
03C0  0023     MOVLB 0x3
03C1  0091     MOVWF EEADR
98:                                EEDAT = EE_STORE.EE_DATA[COUNT];
020F  0020     MOVLB 0x0
0210  3524     LSLF COUNT, W
0211  3E50     ADDLW 0x50
0212  0086     MOVWF FSR1
0213  0187     CLRF FSR1H
0214  3F40     MOVIW 0[FSR1]
0215  0023     MOVLB 0x3
0216  0093     MOVWF EEDAT
0217  3F41     MOVIW 1[FSR1]
0218  0094     MOVWF EEDATH
03C2  3574     LSLF 0x1F4, W
03C3  3E50     ADDLW 0x50
03C4  0086     MOVWF FSR1L
03C5  0187     CLRF FSR1H
03C6  3F40     MOVIW 0[FSR1]
03C7  0093     MOVWF EEDAT
03C8  3F41     MOVIW 1[FSR1]
03C9  0094     MOVWF EEDATH
99:                                EECON1 = 0x44;
0219  3044     MOVLW 0x44
021A  0095     MOVWF EECON1
03CA  3044     MOVLW 0x44
03CB  0095     MOVWF EECON1
100:                               EECON2 = 0x55;
021B  3055     MOVLW 0x55
021C  0096     MOVWF EECON2
03CC  3055     MOVLW 0x55
03CD  0096     MOVWF EECON2
101:                               EECON2 = 0xAA;
021D  30AA     MOVLW 0xAA
021E  0096     MOVWF EECON2
03CE  30AA     MOVLW 0xAA
03CF  0096     MOVWF EECON2
102:                               EECON1bits.WR = 1;
021F  1495     BSF EECON1, 0x1
03D0  1495     BSF EECON1, 0x1
103:                               NOP();
0220  0000     NOP
03D1  0000     NOP
104:                               NOP();
0221  0000     NOP
03D2  0000     NOP
105:                               INTCONbits.GIE = 1;
0222  178B     BSF INTCON, 0x7
0223  2AB4     GOTO 0x2B4
03D3  178B     BSF INTCON, 0x7
03D4  2C5F     GOTO 0x45F
106:                               return;
107:                           }
108:                           COUNT++;
0224  3001     MOVLW 0x1
0225  00A0     MOVWF 0x1A0
0226  0820     MOVF 0x1A0, W
0227  07A4     ADDWF 0x1A4, F
03D5  3001     MOVLW 0x1
03D6  00F0     MOVWF 0x1F0
03D7  0870     MOVF 0x1F0, W
03D8  07F4     ADDWF 0x1F4, F
109:                           EEADR = EE_STORE.EE_ADRS++;
0228  084F     MOVF 0x1CF, W
0229  0023     MOVLB 0x3
022A  0092     MOVWF EEADRH
022B  0020     MOVLB 0x0
022C  084E     MOVF 0x4E, W
022D  0023     MOVLB 0x3
022E  0091     MOVWF EEADR
022F  3001     MOVLW 0x1
0230  0020     MOVLB 0x0
0231  07CE     ADDWF 0x4E, F
0232  3000     MOVLW 0x0
0233  3DCF     ADDWFC 0x4F, F
03D9  084F     MOVF 0x4F, W
03DA  0023     MOVLB 0x3
03DB  0092     MOVWF EEADRH
03DC  0020     MOVLB 0x0
03DD  084E     MOVF 0x4E, W
03DE  0023     MOVLB 0x3
03DF  0091     MOVWF EEADR
03E0  3001     MOVLW 0x1
03E1  0020     MOVLB 0x0
03E2  07CE     ADDWF 0x4E, F
03E3  3000     MOVLW 0x0
03E4  3DCF     ADDWFC 0x4F, F
110:                       }while(COUNT < 4);
0234  3004     MOVLW 0x4
0235  0224     SUBWF COUNT, W
0236  1C03     BTFSS STATUS, 0x0
0237  2A39     GOTO 0x239
0238  2A3A     GOTO 0x23A
0239  29FF     GOTO 0x1FF
03E5  3004     MOVLW 0x4
03E6  0274     SUBWF COUNT, W
03E7  1C03     BTFSS STATUS, 0x0
03E8  2BEA     GOTO 0x3EA
03E9  2BEB     GOTO 0x3EB
03EA  2BB2     GOTO 0x3B2
111:                       INTCONbits.GIE = 1;
023A  178B     BSF INTCON, 0x7
03EB  178B     BSF INTCON, 0x7
112:                       return;
023B  2AB4     GOTO 0x2B4
03EC  2C5F     GOTO 0x45F
113:                       
114:                   case EE_VERIFY_ROM:                                                     //データEEPROM書込成否チェック
115:                       do{
116:                           if(EE_STORE.EE_REPORT[COUNT]){
023C  0824     MOVF COUNT, W
023D  3E58     ADDLW 0x58
023E  0086     MOVWF FSR1
023F  0187     CLRF FSR1H
0240  0801     MOVF INDF1, W
0241  1903     BTFSC STATUS, 0x2
0242  2A44     GOTO 0x244
0243  2A45     GOTO 0x245
0244  2A80     GOTO 0x280
03ED  0874     MOVF COUNT, W
03EE  3E58     ADDLW 0x58
03EF  0086     MOVWF FSR1
03F0  0187     CLRF FSR1H
03F1  0801     MOVF INDF1, W
03F2  1903     BTFSC STATUS, 0x2
03F3  2BF5     GOTO 0x3F5
03F4  2BF6     GOTO 0x3F6
03F5  2C2A     GOTO 0x42A
117:                               EEADR = EE_STORE.EE_ADRS;
0245  084F     MOVF 0x4F, W
0246  0023     MOVLB 0x3
0247  0092     MOVWF EEADRH
0248  0020     MOVLB 0x0
0249  084E     MOVF 0x4E, W
024A  0023     MOVLB 0x3
024B  0091     MOVWF EEADR
03F6  084F     MOVF 0x1CF, W
03F7  0023     MOVLB 0x3
03F8  0092     MOVWF EEADRH
03F9  0020     MOVLB 0x0
03FA  084E     MOVF 0x4E, W
03FB  0023     MOVLB 0x3
03FC  0091     MOVWF EEADR
118:                               EECON1 = 0x01;
024C  3001     MOVLW 0x1
024D  0095     MOVWF EECON1
03FD  3001     MOVLW 0x1
03FE  0095     MOVWF EECON1
119:                               while (EECON1bits.RD);
024E  1815     BTFSC EECON1, 0x0
024F  2A51     GOTO 0x251
0250  2A52     GOTO 0x252
0251  2A4E     GOTO 0x24E
03FF  1815     BTFSC EECON1, 0x0
0400  2C02     GOTO 0x402
0401  2C03     GOTO 0x403
0402  2BFF     GOTO 0x3FF
120:                               EE_STORE.EE_DATA[COUNT] = EEDAT;
0252  0020     MOVLB 0x0
0253  3524     LSLF COUNT, W
0254  3E50     ADDLW 0x50
0255  0086     MOVWF FSR1
0256  0187     CLRF FSR1H
0257  0023     MOVLB 0x3
0258  0813     MOVF EEDAT, W
0259  3FC0     MOVWI 0[FSR1]
025A  0814     MOVF EEDATH, W
025B  3FC1     MOVWI 1[FSR1]
0403  3574     LSLF 0x1F4, W
0404  3E50     ADDLW 0x50
0405  0086     MOVWF FSR1L
0406  0187     CLRF FSR1H
0407  0813     MOVF EEDAT, W
0408  3FC0     MOVWI 0[FSR1]
0409  0814     MOVF EEDATH, W
040A  3FC1     MOVWI 1[FSR1]
121:                               if (EEDAT != EE_STORE.EE_DATA[COUNT]) {
025C  0020     MOVLB 0x0
025D  3524     LSLF COUNT, W
025E  3E50     ADDLW 0x50
025F  0086     MOVWF FSR1
0260  0187     CLRF FSR1H
0261  3F40     MOVIW 0[FSR1]
0262  00A0     MOVWF __pcstackBANK0
0263  3F41     MOVIW 1[FSR1]
0264  00A1     MOVWF 0x21
0265  0023     MOVLB 0x3
0266  0814     MOVF EEDATH, W
0267  0020     MOVLB 0x0
0268  0621     XORWF 0x21, W
0269  1D03     BTFSS STATUS, 0x2
026A  2A6F     GOTO 0x26F
026B  0023     MOVLB 0x3
026C  0813     MOVF EEDAT, W
026D  0020     MOVLB 0x0
026E  0620     XORWF __pcstackBANK0, W
026F  1903     BTFSC STATUS, 0x2
0270  2A72     GOTO 0x272
0271  2A73     GOTO 0x273
0272  2A7A     GOTO 0x27A
040B  3574     LSLF COUNT, W
040C  3E50     ADDLW 0x50
040D  0086     MOVWF FSR1
040E  0187     CLRF FSR1H
040F  3F40     MOVIW 0[FSR1]
0410  00F0     MOVWF __pcstackCOMMON
0411  3F41     MOVIW 1[FSR1]
0412  00F1     MOVWF 0x71
0413  0814     MOVF 0x14, W
0414  0671     XORWF 0x71, W
0415  1D03     BTFSS STATUS, 0x2
0416  2C19     GOTO 0x419
0417  0813     MOVF 0x13, W
0418  0670     XORWF __pcstackCOMMON, W
0419  1903     BTFSC STATUS, 0x2
041A  2C1C     GOTO 0x41C
041B  2C1D     GOTO 0x41D
041C  2C24     GOTO 0x424
122:                                   EE_STORE.EE_REPORT[COUNT] = 0xFF;
0273  0824     MOVF COUNT, W
0274  3E58     ADDLW 0x58
0275  0086     MOVWF FSR1
0276  0187     CLRF FSR1H
0277  30FF     MOVLW 0xFF
0278  0081     MOVWF INDF1
041D  0874     MOVF COUNT, W
041E  3E58     ADDLW 0x58
041F  0086     MOVWF FSR1
0420  0187     CLRF FSR1H
0421  30FF     MOVLW 0xFF
0422  0081     MOVWF INDF1
123:                               } else {
0279  2AB4     GOTO 0x2B4
0423  2C5F     GOTO 0x45F
124:                                   EE_STORE.EE_REPORT[COUNT] = 0x00;
027A  0824     MOVF COUNT, W
027B  3E58     ADDLW 0x58
027C  0086     MOVWF FSR1
027D  0187     CLRF FSR1H
027E  0181     CLRF INDF1
027F  2AB4     GOTO 0x2B4
0424  0874     MOVF COUNT, W
0425  3E58     ADDLW 0x58
0426  0086     MOVWF FSR1
0427  0187     CLRF FSR1H
0428  0181     CLRF INDF1
0429  2C5F     GOTO 0x45F
125:                               }
126:                               return;
127:                           }
128:                           COUNT++;
0280  3001     MOVLW 0x1
0281  00A0     MOVWF __pcstackBANK0
0282  0820     MOVF __pcstackBANK0, W
0283  07A4     ADDWF COUNT, F
042A  3001     MOVLW 0x1
042B  00F0     MOVWF __pcstackCOMMON
042C  0870     MOVF __pcstackCOMMON, W
042D  07F4     ADDWF COUNT, F
129:                           EEADR = EE_STORE.EE_ADRS++;
0284  084F     MOVF 0x4F, W
0285  0023     MOVLB 0x3
0286  0092     MOVWF EEADRH
0287  0020     MOVLB 0x0
0288  084E     MOVF 0x4E, W
0289  0023     MOVLB 0x3
028A  0091     MOVWF EEADR
028B  3001     MOVLW 0x1
028C  0020     MOVLB 0x0
028D  07CE     ADDWF 0x4E, F
028E  3000     MOVLW 0x0
028F  3DCF     ADDWFC 0x4F, F
042E  084F     MOVF 0x4F, W
042F  0023     MOVLB 0x3
0430  0092     MOVWF EEADRH
0431  0020     MOVLB 0x0
0432  084E     MOVF 0x4E, W
0433  0023     MOVLB 0x3
0434  0091     MOVWF EEADR
0435  3001     MOVLW 0x1
0436  0020     MOVLB 0x0
0437  07CE     ADDWF 0x4E, F
0438  3000     MOVLW 0x0
0439  3DCF     ADDWFC 0x4F, F
130:                       }while(COUNT < 4);
0290  3004     MOVLW 0x4
0291  0224     SUBWF COUNT, W
0292  1C03     BTFSS STATUS, 0x0
0293  2A95     GOTO 0x295
0294  2A96     GOTO 0x296
0295  2A3C     GOTO 0x23C
043A  3004     MOVLW 0x4
043B  0274     SUBWF COUNT, W
043C  1C03     BTFSS STATUS, 0x0
043D  2C3F     GOTO 0x43F
043E  2C40     GOTO 0x440
043F  2BED     GOTO 0x3ED
131:                       INTCONbits.GIE = 1;
0296  178B     BSF INTCON, 0x7
0440  178B     BSF INTCON, 0x7
132:                       return;
0297  2AB4     GOTO 0x2B4
0441  2C5F     GOTO 0x45F
133:           
134:                   default:                                                                //それ以外はチェック無しで返す。
135:                       return;
136:               }
0298  084C     MOVF EE_STORE, W
0299  00A0     MOVWF __pcstackBANK0
029A  01A1     CLRF 0x21
029B  0821     MOVF 0x21, W
029C  3A00     XORLW 0x0
029D  1903     BTFSC STATUS, 0x2
029E  2AA0     GOTO 0x2A0
029F  2AB4     GOTO 0x2B4
02A0  0820     MOVF __pcstackBANK0, W
02A1  3A00     XORLW 0x0
02A2  1903     BTFSC STATUS, 0x2
02A3  28FA     GOTO 0xFA
02A4  3A01     XORLW 0x1
02A5  1903     BTFSC STATUS, 0x2
02A6  293B     GOTO 0x13B
02A7  3A03     XORLW 0x3
02A8  1903     BTFSC STATUS, 0x2
02A9  2970     GOTO 0x170
02AA  3A01     XORLW 0x1
02AB  1903     BTFSC STATUS, 0x2
02AC  29B5     GOTO 0x1B5
02AD  3A07     XORLW 0x7
02AE  1903     BTFSC STATUS, 0x2
02AF  29FF     GOTO 0x1FF
02B0  3A01     XORLW 0x1
02B1  1903     BTFSC STATUS, 0x2
02B2  2A3C     GOTO 0x23C
02B3  2AB4     GOTO 0x2B4
0442  0020     MOVLB 0x0
0443  084C     MOVF EE_STORE, W
0444  00F0     MOVWF __pcstackCOMMON
0445  01F1     CLRF 0x71
0446  0871     MOVF 0x71, W
0447  3A00     XORLW 0x0
0448  1903     BTFSC STATUS, 0x2
0449  2C4B     GOTO 0x44B
044A  2C5F     GOTO 0x45F
044B  0870     MOVF __pcstackCOMMON, W
044C  3A00     XORLW 0x0
044D  1903     BTFSC STATUS, 0x2
044E  2AB8     GOTO 0x2B8
044F  3A01     XORLW 0x1
0450  1903     BTFSC STATUS, 0x2
0451  2AF6     GOTO 0x2F6
0452  3A03     XORLW 0x3
0453  1903     BTFSC STATUS, 0x2
0454  2B29     GOTO 0x329
0455  3A01     XORLW 0x1
0456  1903     BTFSC STATUS, 0x2
0457  2B6C     GOTO 0x36C
0458  3A07     XORLW 0x7
0459  1903     BTFSC STATUS, 0x2
045A  2BB2     GOTO 0x3B2
045B  3A01     XORLW 0x1
045C  1903     BTFSC STATUS, 0x2
045D  2BED     GOTO 0x3ED
045E  2C5F     GOTO 0x45F
137:           }
02B4  0008     RETURN
045F  0008     RETURN
138:           void PACKET_CONTROL(UnCHR *DATA, UnCHR *P_RANGE){
0507  0020     MOVLB 0x0
0508  00A6     MOVWF DATA
139:               switch(DATA[1] >> 5){
0509  2D4C     GOTO 0x54C
140:                   case 0:
141:                       COM_FLAG &= 0xF7;
050A  30F7     MOVLW 0xF7
050B  00A3     MOVWF 0x23
050C  0823     MOVF 0x23, W
050D  05DD     ANDWF COM_FLAG, F
142:                       DEC_SET(DATA,P_RANGE);
050E  0822     MOVF P_RANGE, W
050F  00A0     MOVWF __pcstackBANK0
0510  0826     MOVF DATA, W
0511  3185     MOVLP 0x5
0512  25D5     CALL 0x5D5
0513  3185     MOVLP 0x5
0514  2D77     GOTO 0x577
143:                       return;
144:                   case 1:
145:                       COM_FLAG |= 0x08;
0515  15DD     BSF COM_FLAG, 0x3
146:                       DEC_SET(DATA,P_RANGE);
0516  0822     MOVF P_RANGE, W
0517  00A0     MOVWF __pcstackBANK0
0518  0826     MOVF DATA, W
0519  3185     MOVLP 0x5
051A  25D5     CALL 0x5D5
051B  3185     MOVLP 0x5
051C  2D77     GOTO 0x577
147:                       return;
148:                   case 2:
149:                       COM_FLAG |= 0x10;
051D  165D     BSF COM_FLAG, 0x4
150:                       PWM_SET(DATA,P_RANGE);
051E  0822     MOVF P_RANGE, W
051F  00A0     MOVWF __pcstackBANK0
0520  0826     MOVF DATA, W
0521  3185     MOVLP 0x5
0522  25D3     CALL 0x5D3
0523  3185     MOVLP 0x5
0524  2D77     GOTO 0x577
151:                       return;
152:                   case 3:
153:                       COM_FLAG &= 0xEF;
0525  30EF     MOVLW 0xEF
0526  00A3     MOVWF 0x23
0527  0823     MOVF 0x23, W
0528  05DD     ANDWF COM_FLAG, F
154:                       PWM_SET(DATA,P_RANGE);
0529  0822     MOVF P_RANGE, W
052A  00A0     MOVWF __pcstackBANK0
052B  0826     MOVF DATA, W
052C  3185     MOVLP 0x5
052D  25D3     CALL 0x5D3
052E  3185     MOVLP 0x5
052F  2D77     GOTO 0x577
155:                       return;
156:                   case 4:
157:                       COM_FLAG &= 0xDF;
0530  30DF     MOVLW 0xDF
0531  00A3     MOVWF 0x23
0532  0823     MOVF 0x23, W
0533  05DD     ANDWF COM_FLAG, F
158:                       FUNC_SET(DATA,P_RANGE);
0534  0822     MOVF P_RANGE, W
0535  00A0     MOVWF __pcstackBANK0
0536  0826     MOVF DATA, W
0537  3185     MOVLP 0x5
0538  25D4     CALL 0x5D4
0539  3185     MOVLP 0x5
053A  2D77     GOTO 0x577
159:                       return;
160:                   case 5:
161:                       COM_FLAG |= 0x20;
053B  16DD     BSF COM_FLAG, 0x5
162:                       FUNC_SET(DATA,P_RANGE);
053C  0822     MOVF P_RANGE, W
053D  00A0     MOVWF __pcstackBANK0
053E  0826     MOVF DATA, W
053F  3185     MOVLP 0x5
0540  25D4     CALL 0x5D4
0541  3185     MOVLP 0x5
0542  2D77     GOTO 0x577
163:                       return;
164:                   case 6:
165:                       NOP();
0543  0000     NOP
166:                       return;
0544  2D77     GOTO 0x577
167:                   case 7:
168:                       CONFIG_SET(DATA,P_RANGE);
0545  0822     MOVF P_RANGE, W
0546  00A0     MOVWF __pcstackBANK0
0547  0826     MOVF DATA, W
0548  3185     MOVLP 0x5
0549  25D6     CALL 0x5D6
054A  3185     MOVLP 0x5
054B  2D77     GOTO 0x577
169:                       return;
170:               }
054C  0A26     INCF DATA, W
054D  0086     MOVWF FSR1
054E  0187     CLRF FSR1H
054F  0801     MOVF INDF1, W
0550  00A3     MOVWF 0x23
0551  3005     MOVLW 0x5
0552  36A3     LSRF 0x23, F
0553  0B89     DECFSZ WREG, F
0554  2D52     GOTO 0x552
0555  0823     MOVF 0x23, W
0556  00A4     MOVWF COUNT
0557  01A5     CLRF 0x25
0558  0825     MOVF 0x25, W
0559  3A00     XORLW 0x0
055A  1903     BTFSC STATUS, 0x2
055B  2D5D     GOTO 0x55D
055C  2D77     GOTO 0x577
055D  0824     MOVF COUNT, W
055E  3A00     XORLW 0x0
055F  1903     BTFSC STATUS, 0x2
0560  2D0A     GOTO 0x50A
0561  3A01     XORLW 0x1
0562  1903     BTFSC STATUS, 0x2
0563  2D15     GOTO 0x515
0564  3A03     XORLW 0x3
0565  1903     BTFSC STATUS, 0x2
0566  2D1D     GOTO 0x51D
0567  3A01     XORLW 0x1
0568  1903     BTFSC STATUS, 0x2
0569  2D25     GOTO 0x525
056A  3A07     XORLW 0x7
056B  1903     BTFSC STATUS, 0x2
056C  2D30     GOTO 0x530
056D  3A01     XORLW 0x1
056E  1903     BTFSC STATUS, 0x2
056F  2D3B     GOTO 0x53B
0570  3A03     XORLW 0x3
0571  1903     BTFSC STATUS, 0x2
0572  2D43     GOTO 0x543
0573  3A01     XORLW 0x1
0574  1903     BTFSC STATUS, 0x2
0575  2D45     GOTO 0x545
0576  2D77     GOTO 0x577
171:           }
0577  0008     RETURN
172:           void DEC_SET(UnCHR *DATA,UnCHR *P_RANGE){
173:               
174:               
175:           }
05D5  0008     RETURN
176:           void PWM_SET(UnCHR *DATA,UnCHR *P_RANGE){}
05D3  0008     RETURN
177:           void FUNC_SET(UnCHR *DATA,UnCHR *P_RANGE){}
05D4  0008     RETURN
178:           void CONFIG_SET(UnCHR *DATA,UnCHR *P_RANGE){}
05D6  0008     RETURN
---  E:/WATAKUMI/PIC/Project_ATCS/Project_ATCS_Decorder_Main.c  -----------------------------------------
1:             /*
2:              * Project Auto Train Control System 
3:              * Ver 0.1
4:              * 
5:              * Project Maid by WATANABE
6:              * Created on 2023/10/27, 12:07
7:              */
8:             
9:             
10:            #include <xc.h>
11:            #define _XTAL_FREQ 8000000
12:            #include "Project_ATCS_SETUP.h"
13:            
14:            EE_STAGE_DATA EE_STORE __attribute__(()) = {
15:                EE_NEXT,
16:                0xFF,
17:                0x0000,
18:                {0x0055,0x0FFF,0x0FFF,0x0FFF},
19:                {0xAA,0x00,0x00,0x00}
20:            };
21:            const UnCHR DCC_ADRS[5] = {
22:                MuFuD_7bits,
23:                BaAcD_9bits,
24:                MuFuD_14bits,
25:                Reserved_Address,
26:                AEPF
27:            };                                                                              //データ内部
28:            const UnCHR PWM_DATA[64] = {
29:                0x00,0x00,0x7F,0x80,0xBF,0xC0,0xE7,0xE8,0xFC,0xFD,0xFE,0xFF
30:            };
31:            UnCHR STACK[32] __at(0xA0);
32:            
33:            void main(void) {
34:                
35:                OSCCON =  0x72;
0460  3072     MOVLW 0x72
0461  0021     MOVLB 0x1
0462  0099     MOVWF OSCCON
36:                ANSELA =  0x00;
0463  0023     MOVLB 0x3
0464  018C     CLRF ANSELA
37:                
38:                TRISA =   0x04;
0465  3004     MOVLW 0x4
0466  0021     MOVLB 0x1
0467  008C     MOVWF TRISA
39:                PORTA =   0x00;
0468  0020     MOVLB 0x0
0469  018C     CLRF PORTA
40:                
41:                APFCON =  0x03;
046A  3003     MOVLW 0x3
046B  0022     MOVLB 0x2
046C  009D     MOVWF APFCON
42:                
43:                INTCON =  0xC8;
046D  30C8     MOVLW 0xC8
046E  008B     MOVWF INTCON
44:                IOCAP =   0x04;
046F  3004     MOVLW 0x4
0470  0027     MOVLB 0x7
0471  0091     MOVWF IOCAP
45:                PIE1 =    0x81;
0472  3081     MOVLW 0x81
0473  0021     MOVLB 0x1
0474  0091     MOVWF PIE1
46:                PIE2 =    0x10;
0475  3010     MOVLW 0x10
0476  0092     MOVWF PIE2
47:                T1CON =   0x01;
0477  3001     MOVLW 0x1
0478  0020     MOVLB 0x0
0479  0098     MOVWF T1CON
48:                
49:                CCP1CON = 0x0F;
047A  300F     MOVLW 0xF
047B  0025     MOVLB 0x5
047C  0093     MOVWF CCP1CON
50:                PSTR1CON = 0x01;
047D  3001     MOVLW 0x1
047E  0096     MOVWF PSTR1CON
51:                PR2 =     0x19;
047F  3019     MOVLW 0x19
0480  0020     MOVLB 0x0
0481  009B     MOVWF PR2
52:                CCPR1L =  0x3F;
0482  303F     MOVLW 0x3F
0483  0025     MOVLB 0x5
0484  0091     MOVWF CCPR1
53:                T2CON =   0x04;
0485  3004     MOVLW 0x4
0486  0020     MOVLB 0x0
0487  009C     MOVWF T2CON
54:                
55:                EE_STORE.EE_STATE = EE_WRITE_UID; 
0488  3002     MOVLW 0x2
0489  00CC     MOVWF EE_STORE
56:                EEPROM_SELECT();
048A  3180     MOVLP 0x0
048B  20F6     CALL 0xF6
048C  3184     MOVLP 0x4
57:                
58:                while(1){
59:                    
60:                    if(COM_FLAG & 0x04){
048D  0020     MOVLB 0x0
048E  1D5D     BTFSS COM_FLAG, 0x2
048F  2C91     GOTO 0x491
0490  2C92     GOTO 0x492
0491  2C8D     GOTO 0x48D
61:                        UnCHR CHECKSUM = 0x00;
62:                        UnCHR DCC_PACKET_RANGE = STCR;
0492  085C     MOVF STCR, W
0493  00CB     MOVWF DCC_PACKET_RANGE
63:                        UnCHR BYPASS[32];
64:                        UnCHR PACKET = STACK[0];
0494  0021     MOVLB 0x1
0495  0820     MOVF STACK, W
0496  0020     MOVLB 0x0
0497  00C9     MOVWF PACKET
65:                                    
66:                        COM_FLAG = COM_FLAG & 0xFB;
0498  085D     MOVF COM_FLAG, W
0499  39FB     ANDLW 0xFB
049A  00DD     MOVWF COM_FLAG
67:                        do{
68:                            STCR--;
049B  3001     MOVLW 0x1
049C  02DC     SUBWF STCR, F
69:                            BYPASS[STCR] = STACK[STCR];
049D  085C     MOVF STCR, W
049E  3E29     ADDLW 0x29
049F  0086     MOVWF FSR1
04A0  0187     CLRF FSR1H
04A1  085C     MOVF STCR, W
04A2  3EA0     ADDLW 0xA0
04A3  0084     MOVWF FSR0
04A4  0185     CLRF FSR0H
04A5  0800     MOVF INDF0, W
04A6  0081     MOVWF INDF1
70:                        }while(STCR);
04A7  085C     MOVF STCR, W
04A8  1D03     BTFSS STATUS, 0x2
04A9  2CAB     GOTO 0x4AB
04AA  2CAC     GOTO 0x4AC
04AB  2C9B     GOTO 0x49B
71:                        
72:                        if(DCC_PACKET_RANGE < 7){
04AC  3007     MOVLW 0x7
04AD  024B     SUBWF DCC_PACKET_RANGE, W
04AE  1803     BTFSC STATUS, 0x0
04AF  2CB1     GOTO 0x4B1
04B0  2CB2     GOTO 0x4B2
04B1  2C8D     GOTO 0x48D
73:                            CHECKSUM = STACK[DCC_PACKET_RANGE];
04B2  30A0     MOVLW 0xA0
04B3  0086     MOVWF FSR1
04B4  3000     MOVLW 0x0
04B5  0087     MOVWF FSR1H
74:                            for(UnCHR count = 1 ;count < DCC_PACKET_RANGE;count++){
04B6  01CA     CLRF count
04B7  0ACA     INCF count, F
04B8  2CC4     GOTO 0x4C4
75:                                PACKET = PACKET ^ BYPASS[count];
04B9  084A     MOVF count, W
04BA  3E29     ADDLW 0x29
04BB  0086     MOVWF FSR1
04BC  0187     CLRF FSR1H
04BD  0801     MOVF INDF1, W
04BE  0649     XORWF PACKET, W
04BF  00C9     MOVWF PACKET
76:                            }
04C0  3001     MOVLW 0x1
04C1  00A7     MOVWF 0x27
04C2  0827     MOVF 0x27, W
04C3  07CA     ADDWF count, F
04C4  084B     MOVF DCC_PACKET_RANGE, W
04C5  024A     SUBWF count, W
04C6  1C03     BTFSS STATUS, 0x0
04C7  2CC9     GOTO 0x4C9
04C8  2CCA     GOTO 0x4CA
04C9  2CB9     GOTO 0x4B9
77:                            
78:                            if(PACKET == STACK[DCC_PACKET_RANGE]){
04CA  084B     MOVF DCC_PACKET_RANGE, W
04CB  3EA0     ADDLW 0xA0
04CC  0086     MOVWF FSR1
04CD  0187     CLRF FSR1H
04CE  0801     MOVF INDF1, W
04CF  0649     XORWF PACKET, W
04D0  1D03     BTFSS STATUS, 0x2
04D1  2CD3     GOTO 0x4D3
04D2  2CD4     GOTO 0x4D4
04D3  2C8D     GOTO 0x48D
79:                                if(BYPASS[0] == Broadcast_Address){
04D4  0829     MOVF BYPASS, W
04D5  1D03     BTFSS STATUS, 0x2
04D6  2CD8     GOTO 0x4D8
04D7  2CD9     GOTO 0x4D9
04D8  2CE0     GOTO 0x4E0
80:                                    PACKET_CONTROL(BYPASS,&DCC_PACKET_RANGE);
04D9  304B     MOVLW 0x4B
04DA  00A2     MOVWF P_RANGE
04DB  3029     MOVLW 0x29
04DC  3185     MOVLP 0x5
04DD  2507     CALL 0x507
04DE  3184     MOVLP 0x4
81:                                }else if(BYPASS[0] <= MuFuD_7bits){
04DF  2C8D     GOTO 0x48D
04E0  3080     MOVLW 0x80
04E1  0229     SUBWF BYPASS, W
04E2  1803     BTFSC STATUS, 0x0
04E3  2CE5     GOTO 0x4E5
04E4  2CE6     GOTO 0x4E6
04E5  2C8D     GOTO 0x48D
82:                                    EE_STORE.EE_ADRS = 0x00;
04E6  01CE     CLRF 0x4E
04E7  01CF     CLRF 0x4F
83:                                    EE_STORE.EE_STATE = EE_READ_S;
04E8  01CC     CLRF EE_STORE
84:                                    EE_STORE.EE_CONFIG = EUID_CON;
04E9  3040     MOVLW 0x40
04EA  00CD     MOVWF 0x4D
85:                                    EE_STORE.EE_REPORT[0] = 0xAA;
04EB  30AA     MOVLW 0xAA
04EC  00D8     MOVWF 0x58
86:                                    EEPROM_SELECT();
04ED  3180     MOVLP 0x0
04EE  20F6     CALL 0xF6
04EF  3184     MOVLP 0x4
87:                                    if(BYPASS[0] == EE_STORE.EE_DATA[0]){
04F0  0020     MOVLB 0x0
04F1  0829     MOVF BYPASS, W
04F2  00A7     MOVWF 0x27
04F3  01A8     CLRF 0x28
04F4  0851     MOVF 0x51, W
04F5  0628     XORWF 0x28, W
04F6  1D03     BTFSS STATUS, 0x2
04F7  2CFA     GOTO 0x4FA
04F8  0850     MOVF 0x50, W
04F9  0627     XORWF 0x27, W
04FA  1D03     BTFSS STATUS, 0x2
04FB  2CFD     GOTO 0x4FD
04FC  2CFE     GOTO 0x4FE
04FD  2D05     GOTO 0x505
88:                                        PACKET_CONTROL(BYPASS,&DCC_PACKET_RANGE);
04FE  304B     MOVLW 0x4B
04FF  00A2     MOVWF P_RANGE
0500  3029     MOVLW 0x29
0501  3185     MOVLP 0x5
0502  2507     CALL 0x507
0503  3184     MOVLP 0x4
0504  2C8D     GOTO 0x48D
89:                                    }
90:                                }
91:                            }       
0505  2C8D     GOTO 0x48D
92:                        }
93:                    }
94:                }
95:                return;
96:            }
---  E:/WATAKUMI/PIC/Project_ATCS/Project_ATCS_Decorder_INTERRUPT.c  ------------------------------------
1:             /*
2:              * File:   Project_ATCS_Decorder_INTERRUPT.c
3:              * Author: WATANABE
4:              *
5:              * Created on 2023/12/05, 3:46
6:              */
7:             
8:             #include <xc.h>
9:             #include "Project_ATCS_SETUP.h"
10:            UnCHR COM_FLAG = 0x00;
11:            UnCHR DATA = 0x00;
12:            UnCHR COUNTER = 0x00;
13:            UnCHR STCR = 0x00;
14:            
15:            void __interrupt() isr(void){                                                   //非同期動作開始地点
0004  147E     BSF btemp, 0x0
0005  3180     MOVLP 0x0
16:                unsigned short COUNT = 0x00; 
17:            
18:                if(INTCONbits.IOCIF){
0006  1C0B     BTFSS INTCON, 0x0
0007  2809     GOTO 0x9
0008  280A     GOTO 0xA
0009  28BD     GOTO 0xBD
19:                    COUNT = TMR1;
000A  0020     MOVLB 0x0
000B  0817     MOVF TMR1H, W
000C  00F7     MOVWF 0x77
000D  0816     MOVF TMR1, W
000E  00F6     MOVWF COUNT
20:                    TMR1 = 0x00;
000F  0196     CLRF TMR1
0010  0197     CLRF TMR1H
21:                    IOCAF = 0x00;
0011  0027     MOVLB 0x7
0012  0193     CLRF IOCAF
22:                    
23:                    if(!(COM_FLAG & 0x01)){                                                 //プリアンブル検出
0013  0020     MOVLB 0x0
0014  185D     BTFSC COM_FLAG, 0x0
0015  2817     GOTO 0x17
0016  2818     GOTO 0x18
0017  284F     GOTO 0x4F
24:                        if(COUNT >= 0x00C0 && COUNT <= 0x0100 && !(COM_FLAG & 0x02) ){
0018  3000     MOVLW 0x0
0019  0277     SUBWF 0x77, W
001A  30C0     MOVLW 0xC0
001B  1903     BTFSC STATUS, 0x2
001C  0276     SUBWF COUNT, W
001D  1C03     BTFSS STATUS, 0x0
001E  2820     GOTO 0x20
001F  2821     GOTO 0x21
0020  2833     GOTO 0x33
0021  3001     MOVLW 0x1
0022  0277     SUBWF 0x77, W
0023  3001     MOVLW 0x1
0024  1903     BTFSC STATUS, 0x2
0025  0276     SUBWF COUNT, W
0026  1803     BTFSC STATUS, 0x0
0027  2829     GOTO 0x29
0028  282A     GOTO 0x2A
0029  2833     GOTO 0x33
002A  18DD     BTFSC COM_FLAG, 0x1
002B  282D     GOTO 0x2D
002C  282E     GOTO 0x2E
002D  2833     GOTO 0x33
25:                            COUNTER++;
002E  3001     MOVLW 0x1
002F  00F5     MOVWF 0x75
0030  0875     MOVF 0x75, W
0031  07F8     ADDWF COUNTER, F
26:                        }
0032  28E0     GOTO 0xE0
27:                        
28:                        else if(COUNT > 0x0080 || COM_FLAG & 0x02){
0033  3000     MOVLW 0x0
0034  0277     SUBWF 0x77, W
0035  3081     MOVLW 0x81
0036  1903     BTFSC STATUS, 0x2
0037  0276     SUBWF COUNT, W
0038  1803     BTFSC STATUS, 0x0
0039  283B     GOTO 0x3B
003A  283C     GOTO 0x3C
003B  2840     GOTO 0x40
003C  1CDD     BTFSS COM_FLAG, 0x1
003D  283F     GOTO 0x3F
003E  2840     GOTO 0x40
003F  28E0     GOTO 0xE0
29:                            if(COUNTER > 11){
0040  300C     MOVLW 0xC
0041  0278     SUBWF COUNTER, W
0042  1C03     BTFSS STATUS, 0x0
0043  2845     GOTO 0x45
0044  2846     GOTO 0x46
0045  28BC     GOTO 0xBC
30:                                COM_FLAG = COM_FLAG | 0x01;
0046  085D     MOVF COM_FLAG, W
0047  3801     IORLW 0x1
0048  00DD     MOVWF COM_FLAG
31:                                COM_FLAG = COM_FLAG & 0xFD;
0049  085D     MOVF COM_FLAG, W
004A  39FD     ANDLW 0xFD
004B  00DD     MOVWF COM_FLAG
32:                                COUNTER = 0x00;
004C  01F8     CLRF COUNTER
33:                                DATA = 0x00;
004D  01F9     CLRF DATA
004E  28E0     GOTO 0xE0
34:                            }    
35:                        }
36:                        
37:                    }else if(COM_FLAG & 0x01){                                              //データ受信
004F  1C5D     BTFSS COM_FLAG, 0x0
0050  2852     GOTO 0x52
0051  2853     GOTO 0x53
0052  28E0     GOTO 0xE0
38:                        if(COUNTER < 8 ){
0053  3008     MOVLW 0x8
0054  0278     SUBWF COUNTER, W
0055  1803     BTFSC STATUS, 0x0
0056  2858     GOTO 0x58
0057  2859     GOTO 0x59
0058  2883     GOTO 0x83
39:                            if(COUNT >= 0x00C0 && COUNT <= 0x0100 && !(COM_FLAG & 0x02)){
0059  3000     MOVLW 0x0
005A  0277     SUBWF 0x77, W
005B  30C0     MOVLW 0xC0
005C  1903     BTFSC STATUS, 0x2
005D  0276     SUBWF COUNT, W
005E  1C03     BTFSS STATUS, 0x0
005F  2861     GOTO 0x61
0060  2862     GOTO 0x62
0061  2872     GOTO 0x72
0062  3001     MOVLW 0x1
0063  0277     SUBWF 0x77, W
0064  3001     MOVLW 0x1
0065  1903     BTFSC STATUS, 0x2
0066  0276     SUBWF COUNT, W
0067  1803     BTFSC STATUS, 0x0
0068  286A     GOTO 0x6A
0069  286B     GOTO 0x6B
006A  2872     GOTO 0x72
006B  18DD     BTFSC COM_FLAG, 0x1
006C  286E     GOTO 0x6E
006D  286F     GOTO 0x6F
006E  2872     GOTO 0x72
40:                                DATA = (UnCHR) (DATA << 1) | 0x01;                          
006F  1403     BSF STATUS, 0x0
0070  0DF9     RLF DATA, F
41:                            }else if(COUNT > 0x0080 || COM_FLAG & 0x02){
0071  282E     GOTO 0x2E
0072  3000     MOVLW 0x0
0073  0277     SUBWF 0x77, W
0074  3081     MOVLW 0x81
0075  1903     BTFSC STATUS, 0x2
0076  0276     SUBWF COUNT, W
0077  1803     BTFSC STATUS, 0x0
0078  287A     GOTO 0x7A
0079  287B     GOTO 0x7B
007A  287F     GOTO 0x7F
007B  1CDD     BTFSS COM_FLAG, 0x1
007C  287E     GOTO 0x7E
007D  287F     GOTO 0x7F
007E  282E     GOTO 0x2E
42:                                DATA = (UnCHR) (DATA << 1) & 0xFE;
007F  3579     LSLF DATA, W
0080  39FE     ANDLW 0xFE
0081  00F9     MOVWF DATA
0082  282E     GOTO 0x2E
43:                            }
44:                            COUNTER++;
45:                        }
46:                        else{                                                               //エンドビット検出
47:                            if(COUNT >= 0x00C0 && COUNT <= 0x0100 && !(COM_FLAG & 0x02)){
0083  3000     MOVLW 0x0
0084  0277     SUBWF 0x77, W
0085  30C0     MOVLW 0xC0
0086  1903     BTFSC STATUS, 0x2
0087  0276     SUBWF COUNT, W
0088  1C03     BTFSS STATUS, 0x0
0089  288B     GOTO 0x8B
008A  288C     GOTO 0x8C
008B  28A6     GOTO 0xA6
008C  3001     MOVLW 0x1
008D  0277     SUBWF 0x77, W
008E  3001     MOVLW 0x1
008F  1903     BTFSC STATUS, 0x2
0090  0276     SUBWF COUNT, W
0091  1803     BTFSC STATUS, 0x0
0092  2894     GOTO 0x94
0093  2895     GOTO 0x95
0094  28A6     GOTO 0xA6
0095  18DD     BTFSC COM_FLAG, 0x1
0096  2898     GOTO 0x98
0097  2899     GOTO 0x99
0098  28A6     GOTO 0xA6
48:                                STACK[STCR] = DATA;
0099  085C     MOVF STCR, W
009A  3EA0     ADDLW 0xA0
009B  0086     MOVWF FSR1
009C  0187     CLRF FSR1H
009D  0879     MOVF DATA, W
009E  0081     MOVWF INDF1
49:                                COM_FLAG = COM_FLAG | 0x04;
009F  085D     MOVF COM_FLAG, W
00A0  3804     IORLW 0x4
00A1  00DD     MOVWF COM_FLAG
50:                                COM_FLAG = COM_FLAG & 0xFE;
00A2  085D     MOVF COM_FLAG, W
00A3  39FE     ANDLW 0xFE
00A4  00DD     MOVWF COM_FLAG
51:                            }else{
00A5  28BA     GOTO 0xBA
52:                                if(STCR == 32){
00A6  3020     MOVLW 0x20
00A7  065C     XORWF STCR, W
00A8  1D03     BTFSS STATUS, 0x2
00A9  28AB     GOTO 0xAB
00AA  28AC     GOTO 0xAC
00AB  28AD     GOTO 0xAD
53:                                    STCR = 0;
00AC  01DC     CLRF STCR
54:                                }
55:                                STACK[STCR] = DATA;
00AD  085C     MOVF STCR, W
00AE  3EA0     ADDLW 0xA0
00AF  0086     MOVWF FSR1
00B0  0187     CLRF FSR1H
00B1  0879     MOVF DATA, W
00B2  0081     MOVWF INDF1
56:                                COM_FLAG = COM_FLAG & 0xFB;
00B3  085D     MOVF COM_FLAG, W
00B4  39FB     ANDLW 0xFB
00B5  00DD     MOVWF COM_FLAG
57:                                STCR++;
00B6  3001     MOVLW 0x1
00B7  00F5     MOVWF 0x75
00B8  0875     MOVF 0x75, W
00B9  07DC     ADDWF STCR, F
58:                            }
59:                            COUNTER = 0x00;
00BA  01F8     CLRF COUNTER
00BB  28E0     GOTO 0xE0
60:                        }
61:                    }
62:                }else if(PIR1bits.TMR1IF){
00BC  28E0     GOTO 0xE0
00BD  0020     MOVLB 0x0
00BE  1C11     BTFSS PIR1, 0x0
00BF  28C1     GOTO 0xC1
00C0  28C2     GOTO 0xC2
00C1  28C7     GOTO 0xC7
63:                    PIR1 = 0x00;
00C2  0191     CLRF PIR1
64:                    COM_FLAG = COM_FLAG | 0x02;
00C3  085D     MOVF COM_FLAG, W
00C4  3802     IORLW 0x2
00C5  00DD     MOVWF COM_FLAG
65:                }else if(PIR2bits.EEIF){
00C6  28E0     GOTO 0xE0
00C7  1E12     BTFSS PIR2, 0x4
00C8  28CA     GOTO 0xCA
00C9  28CB     GOTO 0xCB
00CA  28E0     GOTO 0xE0
66:                    PIR2bits.EEIF = 0;
00CB  1212     BCF PIR2, 0x4
67:                    if(EE_STORE.EE_STATE == EE_WRITE_UID){
00CC  3002     MOVLW 0x2
00CD  064C     XORWF EE_STORE, W
00CE  1D03     BTFSS STATUS, 0x2
00CF  28D1     GOTO 0xD1
00D0  28D2     GOTO 0xD2
00D1  28D5     GOTO 0xD5
68:                        EE_STORE.EE_STATE = EE_VERIFY_UID;
00D2  3003     MOVLW 0x3
00D3  00CC     MOVWF EE_STORE
69:                    }else if(EE_STORE.EE_STATE == EE_WRITE_ROM){
00D4  28DD     GOTO 0xDD
00D5  3004     MOVLW 0x4
00D6  064C     XORWF EE_STORE, W
00D7  1D03     BTFSS STATUS, 0x2
00D8  28DA     GOTO 0xDA
00D9  28DB     GOTO 0xDB
00DA  28DD     GOTO 0xDD
70:                        EE_STORE.EE_STATE = EE_VERIFY_ROM;            
00DB  3005     MOVLW 0x5
00DC  00CC     MOVWF EE_STORE
71:                    }
72:                    EEPROM_SELECT();
00DD  3182     MOVLP 0x2
00DE  22B5     CALL 0x2B5
00DF  3180     MOVLP 0x0
73:                }
74:            }
00E0  107E     BCF btemp, 0x0
---  C:/Users/owata/AppData/Local/Temp/xcAs1428.s  ------------------------------------------------------
05C8  00FE     MOVWF btemp
05C9  0012     MOVIW FSR0++
05CA  001E     MOVWI FSR1++
05CB  0BFE     DECFSZ btemp, F
05CC  2DC9     GOTO 0x5C9
05CD  3400     RETLW 0x0
00E3  30B8     MOVLW 0xB8
00E4  0084     MOVWF FSR0
00E5  3085     MOVLW 0x85
00E6  0085     MOVWF FSR0H
00E7  304C     MOVLW 0x4C
00E8  0086     MOVWF FSR1
00E9  3000     MOVLW 0x0
00EA  0087     MOVWF FSR1H
00EB  3010     MOVLW 0x10
00EC  3185     MOVLP 0x5
00EF  01F8     CLRF COUNTER
00F0  01F9     CLRF DATA
00F1  01DC     CLRF STCR
00F2  01DD     CLRF COM_FLAG
00F3  107E     BCF btemp, 0x0
00F4  0020     MOVLB 0x0
00F5  2C60     GOTO 0x460
