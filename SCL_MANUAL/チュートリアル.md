# チュートリアル
SCLユーザーガイドは、チュートリアルとリファレンスドキュメントの両方を兼ね備えようとしています。このチュートリアルセクションでは、新しいユーザーにとって意味がある順序で情報を提示しようとしています。

SCLはCやJavaのような大文字小文字を区別するフリーフォーマットの言語です。したがって、以下の2つのプログラムは等価です。

```scl
testbench for "PIC32MX360F512L" is end testbench;
```

と

```scl
testbench for "PIC32MX360F512L" is
end testbench;
```

**注:** SCLは大文字小文字を区別する言語で、CやJavaのようなフリーフォーマットの構文を持っています。

## コメント
SCLのコメントにはCスタイルとVHDLスタイルの2つのバリエーションがあります。

```scl
// Cスタイルのコメント
```

```scl
-- VHDLスタイルのコメント
```

**注:** SCLでは、CスタイルとVHDLスタイルの2つの異なるコメントスタイルが利用できます。

## testbench
すべてのSCLプログラムには、1つだけのテストベンチが含まれている必要があります。テストベンチにはプロセス、変数、定数などが含まれます。また、空であっても構いませんが、それを行う理由はほとんどありません。

基本的な構文を示すために、以下は空のテストベンチです：

```scl
testbench for "PIC32MX360F512L" is
begin
   // プロセス、変数などがここに入ります
end testbench;
```

MPLAB IDEの以前のバージョンでは、デバイスの名前はSCLコードが実行されるプロジェクトのデバイスと一致する必要がありました。しかし、MPLAB Xではデバイス名は無視され、装飾的なものに過ぎません。

## configuration
SCLプログラムにはオプションで構成が含まれる場合があります。構成が存在する場合、それはテストベンチの前に配置され、ユーザーのPICソフトウェアからの共有ラベルやアドレスの宣言を含みます。テストベンチと同様に、構成も空にすることができますが、その理由はほとんどありません。

基本的な構文を示すために、以下は空の構成です：

```scl
configuration for "PIC32MX360F512L" is
   // 共有変数やラベルなどがここに入ります
end configuration;
```

テストベンチと同様に、デバイス名は無視されますが、存在する必要があります。

## process
プロセスは、SCLにおける基本的なコード要素です。これは実行されるイベントのシーケンスを表します。

以下はプロセスの基本的な構文です。

```scl
process is
   begin
      // プロセスの文がここに入ります
   end process;
```

テストベンチには複数のプロセスが含まれる可能性があります。

```scl
testbench for "PIC32MX360F512L" is
   process is -- 1つ目のプロセス
      begin
      end process;
   process is -- 2つ目のプロセス
      begin
      end process;
end testbench;
```

最後に、プロセスには名前を付けることができます。

```scl
processName: process is
   begin
end process processName;
```

または、代替として

```scl
processName: is process is
   begin
end process processName;
```

プロセス名は装飾的なものであり、ただし一意である必要があります。プロセス名は将来のSCLのバージョンで使用される可能性があります。

## wait
`wait` ステートメントは、SCLに対して、包含するプロセスの実行を停止するよう指示します。

SCLは、プロセス内のステートメントを `wait` ステートメントに遭遇するまで実行します。プロセスの終わりに遭遇すると、SCLは単にプロセスの最初に戻り、再度開始します。そのため、すべてのプロセスには少なくとも1つの `wait` ステートメントが必要です。それがないと、プロセスは無限ループを実行し、シミュレータを停止させます。幸いにも、SCLパーサは `wait` ステートメントのないプロセスを検出し、次の警告を発行し、ロードを拒否します。

```
SIM004: Failed to parse SCL SCL022: Process contains neither a wait statement nor a sensitivity list line(#)
```

`wait` ステートメントには4つの形式があります。

1. `wait;` （修飾なし）
2. `wait on sensitivity;` （感度待ち）
3. `wait until condition;` （条件待ち）
4. `wait for timeout;` （タイムアウト待ち）

### 修飾なしの `wait`

最も単純な `wait` の形式は引数なしで修飾されていません。これは、プロセスのステートメントの実行を停止するだけでなく、プロセスが完了し終了していることをSCLに伝えます。

```scl
process is
   begin
      wait;  -- プロセスを即座に終了する
   end process;
```

### 感度待ち

感度待ちステートメントは、値の変更を待ちます。いくつかの種類の値があります。

```scl
wait on RD1;          -- ピンRD1の変更を待つ
wait on userVar;      -- ユーザー変数の変更を待つ
wait on STATUS;       -- STATUS SFRの変更を待つ
wait on PORTD.RD0;    -- PORTDのRD0ビットの変更を待つ
```

### 条件待ち

条件待ちステートメントは、式が `true` になるのを待ちます。

```scl
wait until PORTA == 128;          -- SFR PORTAが128（0x80）に等しくなるのを待つ
wait until RD1 == '1';            -- ピンRD1がHighになるのを待つ
wait until ADCON.ADON == '1';     -- SFR ADCONのフィールドADONが1になるのを待つ
wait until PC == 4;               -- PCが4になるのを待つ
```

条件待ちは、ブール式内のレジスタやピンの値が変更されるのを待ってから、ブール式をテストするように実際には待ちます。これは、プロセス内に他の `wait` ステートメントがない場合に発生する無限ループプロセスを防ぐためです。たとえば：

```scl
process is;
   begin
   wait until RC6 == '1';   -- もしSCLがここでRC6の値が変わるのを待っていない場合...
   report("RC6 was '1'");   -- ...このプロセスはこの報告ステートメントを無限に実行する
   end process;
```

この場合、ブール式が条件待ちステートメントが実行されるときに既に `true` の場合、無限ループが発生する可能性があります。プロセスは条件をテストする前に、レジスタやピンの値が変更されるのを待ちます。これにより、プロセスが条件をテストする前に無限ループに陥るのを防ぎます。

```scl
process is;
   begin
   RC6 <= '1';             -- 次のブール式がtrueになるように強制
   wait until RC6 == '1';  -- ...プロセスはまずRC6の値が変わるのを待ちます
   report("RC6 was '1'");  -- ...この行は実行されません
   end process;
```

この問題を回避するには、`wait` の前に `if` ステートメントを使用します。

```scl
process is;
   begin
   if RC6 != '1' then          -- このプロセスは停止せず、無限にループもしません
      wait until RC6 == '1';
   end if;
   report("RC6 was '1'");
   end process;
```

### タイムアウト待ち

タイムアウト待ちステートメントは、指定された時間だけ待ちます。

```scl
wait for 10 ic;        -- 10命令サイクル待つ
wait for 10 ms;        -- 10ミリ秒待つ
```

### 組み合わせた `wait`

タイムアウト待ちは、感度待ちまたは条件待ちと組み合わせることができます。このように使用されると、タイムアウトは真のタイムアウトになります。

```scl
wait on RD1 for 10 ms;            -- ピンRD1の変更を待つか、10 msが経過するのを待つ
wait until PC = 20 for 20 ic;     -- PCが20になるか、20命令サイクルが経過するのを待つ
```

## 代入
おそらく、最も一般的なSCLステートメントは、値をピン、SFR、SFRフィールド、またはメモリの位置に代入するための代入ステートメントです。

```scl
RA1 <= '1';                 -- ピンRA1をHighに設定
AN0 <= 3500 mv;             -- ピンAN0を3.5 Vに設定
RA0 <= RA1;                 -- ピンRA0をピンRA1の値に設定
ADDRESH <= 128;             -- SFR ADDRESHを128に設定
ADDRESH <= 16#80#;          -- SFR ADDRESHを0x80に設定
ADDRESH <= B"10000000";     -- SFR ADDRESHをバイナリ10000000に設定
ADDRESH <= ADDRESL";        -- SFR ADDRESHをADDRESLに設定
PORTA <= intVar;            -- SFR PORTAを変数intVarの値に設定
SSPCON1.CKP <= '1';         -- フィールドSSPCON1.CKPを1に設定
ADCON0.ADCS <= "10";        -- フィールドADCON0.ADCSを2に設定
```

ユーザー変数への代入は異なる構文を使用します。そしてもちろん、ユーザー変数のタイプに依存します。

```scl
intVar  := 123;             -- intVarを123に設定
timeVar := 10 ms;           -- timeVarを10 msに設定
strVar  := "test";          -- strVarを"test"に設定
intVar  := PORTA;           -- intVarをSFR PORTAの値に設定
```

## 算術演算
数学的な操作は、SFRや整数変数などのワードサイズの整数値に対して行うことができます。

```scl
intVal <= intVal [+|-|*|/] intVal;
```

整数値は、SFR、整数変数、整数定数、またはワードサイズの共有変数である可能性があります。

```scl
TMR1 <= TMR1 + 1;
intVar := WREG / 5;
sharedVar <= intVar + RCREG * 3 - 1;
```

## if
If ステートメントは、条件に基づいた分岐を提供します。

```scl
if booleanExpression then
   -- SCLステートメント
else   -- オプション
   -- SCLステートメント
end if;
```

ブール式は期待通りです。以下はいくつかの例です。

```scl
-- RD0の反転をRD1にエコーする
wait on RD0;
if RD0 == '1' then
   RD1 <= '0';
else
   RD1 <= '1';
end if;

-- ピン電圧のテスト
if RD0 > 2500 mv then
   RD1 <= '0';
   RD2 <= '0';
end if;

-- SFRフィールドのテスト
if ADCON.ADCS == "00" then
   ADCON.ADON = '1';
end if;

-- ブール変数のテスト
if testBool then
   RD1 <= '0';
   RD2 <= '0';
end if;
```
## loop
Loop ステートメントは、ループ機能を提供します。

```scl
loop
   -- SCLステートメント
   exit when booleanExpression     -- オプション
end loop;
```


ブール式は期待通りです。以下はいくつかの例です。

```scl
-- 無限ループ（exit whenなし）
loop
   RD1 <= '0';
   wait on RD1;
end loop;

-- PCがfooラベルになるまでクロック
loop
   RD0 <= '0';
   wait 4 ic;
   RD0 <= '1';
   wait 4 ic;
   exit when PC == foo;
end loop;

-- 修飾なしの終了（これは無理やりですが！）
loop
   AN1 <= 3500 mv;
   exit;             -- 無条件の終了
end loop;
```

注意点として、ループには複数の `exit when` 条件がある可能性があることです。

```scl
-- 複数の終了条件
loop
   wait on RD1;
   RD0 <= '0';
   exit when STATUS.Z == 0;
   exit when RD2 == '0';
end loop;
```

## while
While ループは、Loop ステートメントの変種であり、ブール終了条件がループの開始時に与えられる形式です。

```scl
while booleanExpression loop
   -- SCLステートメント
   exit when booleanExpression     -- オプション
end loop;
```

ブール式は期待通りです。以下はいくつかの例です。

```scl
-- 無限ループ
while true loop
   RD1 <= '0';
   wait on RD1;
end loop;

-- PC > 0x2000までループ
while PC <= #16#2000# loop
   PIR3.ADIF <= 1;
   wait 200 us;
end loop;
```

注意点として、while ステートメントに独自のブール式があるにもかかわらず、ループには引き続き `exit when` ステートメントを含めることができます。

```scl
-- PIR2.EEIFがクリアされるまでループ
while PIR2.EEIF == 1 loop
   RD1 <= '1';
   wait on RD0;
   exit when PC == 0;   -- デバイスのリセット
end loop;
```

## 組み込み関数
ユーザー定義の手続きや関数のサポートは現時点では不完全です。ただし、SCLにはいくつかの有用な組み込み手続きと関数が用意されています。

- `accessin`: 指定されたファイルからデータを読み取り、指定された場所に挿入します。
- `endfile`: ファイルの終わりを検出します。
- `file_close`: ファイルを閉じます。
- `file_open`: ファイルを開きます。
- `match`: 文字列内に部分文字列が存在するかどうかを判断します。
- `now`: 現在のシミュレーション時間（命令サイクル）。
- `packetin`: UART挿入とともに使用される非常に特殊化された文字列パーサー。
- `random_time`: ランダムな時間値を返します。
- `read`: 文字列から値を解析します。
- `readline`: ファイルから1行のテキストを閉じます。
- `report`: デバッグ用のルーチンで、テキストをSimulatorコンソールに出力します（MPLAB IDE内）。